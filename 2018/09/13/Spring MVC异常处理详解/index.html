<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spring MVC异常处理详解 | Charrington House</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring MVC异常处理详解</h1><a id="logo" href="/.">Charrington House</a><p class="description">是谁出的题这么难啊，到处都是正确的答案。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring MVC异常处理详解</h1><div class="post-meta">Sep 13, 2018<span> | </span><span class="category"><a href="/categories/Spring/">Spring</a></span></div><div class="post-content"><p>Spring MVC异常相关类如下：<br><img src="https://i.imgur.com/R4WlL2C.jpg" alt=""><br>在Spring MVC中，所有用于处理在请求映射和请求处理过程中抛出的异常的类，都要实现HandlerExceptionResolver接口。AbstractHandlerExceptionResolver实现该接口和Orderd接口，是HandlerExceptionResolver类的实现的基类。ResponseStatusExceptionResolver等具体的异常处理类均在AbstractHandlerExceptionResolver之上，实现了具体的异常处理方式。一个基于Spring MVC的Web应用程序中，可以存在多个实现了HandlerExceptionResolver的异常处理类，他们的执行顺序，由其order属性决定, order值越小，越是优先执行, 在执行到第一个返回不是null的ModelAndView的Resolver时，不再执行后续的尚未执行的Resolver的异常处理方法。</p>
<p>下面我逐个介绍一下SpringMVC提供的这些异常处理类的功能。</p>
<h1 id="DefaultHandlerExceptionResolver"><a href="#DefaultHandlerExceptionResolver" class="headerlink" title="DefaultHandlerExceptionResolver"></a>DefaultHandlerExceptionResolver</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleNoSuchRequestHandlingMethod</span><br><span class="line">handleHttpRequestMethodNotSupported</span><br><span class="line">handleHttpMediaTypeNotSupported</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleServletRequestBindingException</span><br><span class="line">handleTypeMismatch</span><br><span class="line">handleHttpMessageNotReadable</span><br><span class="line">handleHttpMessageNotWritable</span><br><span class="line">handleMethodArgumentNotValidException</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleMissingServletRequestPartException</span><br><span class="line">handleBindException</span><br></pre></td></tr></table></figure>
<h1 id="ResponseStatusExceptionResolver"><a href="#ResponseStatusExceptionResolver" class="headerlink" title="ResponseStatusExceptionResolver"></a>ResponseStatusExceptionResolver</h1><p>用来支持ResponseStatus的使用，处理使用了ResponseStatus注解的异常，根据注解的内容，返回相应的HTTP Status Code和内容给客户端。如果Web应用程序中配置了ResponseStatusExceptionResolver，那么我们就可以使用ResponseStatus注解来注解我们自己编写的异常类，并在Controller中抛出该异常类，之后ResponseStatusExceptionResolver就会自动帮我们处理剩下的工作。</p>
<p>这是一个自己编写的异常，用来表示订单不存在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ResponseStatus(value=HttpStatus.NOT_FOUND, reason=&quot;No such Order&quot;)  // 404</span><br><span class="line">   public class OrderNotFoundException extends RuntimeException &#123;</span><br><span class="line">       // ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个使用该异常的Controller方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/orders/&#123;id&#125;&quot;, method=GET)</span><br><span class="line">    public String showOrder(@PathVariable(&quot;id&quot;) long id, Model model) &#123;</span><br><span class="line">        Order order = orderRepository.findOrderById(id);</span><br><span class="line">        if (order == null) throw new OrderNotFoundException(id);</span><br><span class="line">        model.addAttribute(order);</span><br><span class="line">        return &quot;orderDetail&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当OrderNotFoundException被抛出时，ResponseStatusExceptionResolver会返回给客户端一个HTTP Status Code为404的响应。</p>
<h1 id="AnnotationMethodHandlerExceptionResolver和ExceptionHandlerExceptionResolver"><a href="#AnnotationMethodHandlerExceptionResolver和ExceptionHandlerExceptionResolver" class="headerlink" title="AnnotationMethodHandlerExceptionResolver和ExceptionHandlerExceptionResolver"></a>AnnotationMethodHandlerExceptionResolver和ExceptionHandlerExceptionResolver</h1><p> #<br>用来支持ExceptionHandler注解，使用被ExceptionHandler注解所标记的方法来处理异常。其中AnnotationMethodHandlerExceptionResolver在3.0版本中开始提供，ExceptionHandlerExceptionResolver在3.1版本中开始提供，从3.2版本开始，Spring推荐使用ExceptionHandlerExceptionResolver。<br>如果配置了AnnotationMethodHandlerExceptionResolver和ExceptionHandlerExceptionResolver这两个异常处理bean之一，那么我们就可以使用ExceptionHandler注解来处理异常。</p>
<p>下面是几个ExceptionHandler注解的使用例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ExceptionHandlingController &#123;</span><br><span class="line"></span><br><span class="line">  // @RequestHandler methods</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  // 以下是异常处理方法</span><br><span class="line">  </span><br><span class="line">  // 将DataIntegrityViolationException转化为Http Status Code为409的响应</span><br><span class="line">  @ResponseStatus(value=HttpStatus.CONFLICT, reason=&quot;Data integrity violation&quot;)  // 409</span><br><span class="line">  @ExceptionHandler(DataIntegrityViolationException.class)</span><br><span class="line">  public void conflict() &#123;</span><br><span class="line">    // Nothing to do</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 针对SQLException和DataAccessException返回视图databaseError</span><br><span class="line">  @ExceptionHandler(&#123;SQLException.class,DataAccessException.class&#125;)</span><br><span class="line">  public String databaseError() &#123;</span><br><span class="line">    // Nothing to do.  Returns the logical view name of an error page, passed to</span><br><span class="line">    // the view-resolver(s) in usual way.</span><br><span class="line">    // Note that the exception is _not_ available to this view (it is not added to</span><br><span class="line">    // the model) but see &quot;Extending ExceptionHandlerExceptionResolver&quot; below.</span><br><span class="line">    return &quot;databaseError&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建ModleAndView，将异常和请求的信息放入到Model中，指定视图名字，并返回该ModleAndView</span><br><span class="line">  @ExceptionHandler(Exception.class)</span><br><span class="line">  public ModelAndView handleError(HttpServletRequest req, Exception exception) &#123;</span><br><span class="line">    logger.error(&quot;Request: &quot; + req.getRequestURL() + &quot; raised &quot; + exception);</span><br><span class="line"></span><br><span class="line">    ModelAndView mav = new ModelAndView();</span><br><span class="line">    mav.addObject(&quot;exception&quot;, exception);</span><br><span class="line">    mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class="line">    mav.setViewName(&quot;error&quot;);</span><br><span class="line">    return mav;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，上面例子中的ExceptionHandler方法的作用域，只是在本Controller类中。如果需要使用ExceptionHandler来处理全局的Exception，则需要使用ControllerAdvice注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">class GlobalDefaultExceptionHandler &#123;</span><br><span class="line">    public static final String DEFAULT_ERROR_VIEW = &quot;error&quot;;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = Exception.class)</span><br><span class="line">    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception &#123;</span><br><span class="line">        // 如果异常使用了ResponseStatus注解，那么重新抛出该异常，Spring框架会处理该异常。 </span><br><span class="line">        if (AnnotationUtils.findAnnotation(e.getClass(), ResponseStatus.class) != null)</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        // 否则创建ModleAndView，处理该异常。</span><br><span class="line">        ModelAndView mav = new ModelAndView();</span><br><span class="line">        mav.addObject(&quot;exception&quot;, e);</span><br><span class="line">        mav.addObject(&quot;url&quot;, req.getRequestURL());</span><br><span class="line">        mav.setViewName(DEFAULT_ERROR_VIEW);</span><br><span class="line">        return mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SimpleMappingExceptionResolver"><a href="#SimpleMappingExceptionResolver" class="headerlink" title="SimpleMappingExceptionResolver"></a>SimpleMappingExceptionResolver</h1><p>提供了将异常映射为视图的能力，高度可定制化。其提供的能力有：</p>
<ol>
<li>根据异常的类型，将异常映射到视图；</li>
<li>可以为不符合处理条件没有被处理的异常，指定一个默认的错误返回；</li>
<li>处理异常时，记录log信息；</li>
<li>指定需要添加到Modle中的Exception属性，从而在视图中展示该属性。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc </span><br><span class="line">public class MvcConfiguration extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Bean(name=&quot;simpleMappingExceptionResolver&quot;)</span><br><span class="line">    public SimpleMappingExceptionResolver createSimpleMappingExceptionResolver() &#123;</span><br><span class="line">        SimpleMappingExceptionResolver r = new SimpleMappingExceptionResolver();</span><br><span class="line"></span><br><span class="line">        Properties mappings = new Properties();</span><br><span class="line">        mappings.setProperty(&quot;DatabaseException&quot;, &quot;databaseError&quot;);</span><br><span class="line">        mappings.setProperty(&quot;InvalidCreditCardException&quot;, &quot;creditCardError&quot;);</span><br><span class="line"></span><br><span class="line">        r.setExceptionMappings(mappings);  // 默认为空</span><br><span class="line">        r.setDefaultErrorView(&quot;error&quot;);    // 默认没有</span><br><span class="line">        r.setExceptionAttribute(&quot;ex&quot;); </span><br><span class="line">        r.setWarnLogCategory(&quot;example.MvcLogger&quot;); </span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义ExceptionResolver"><a href="#自定义ExceptionResolver" class="headerlink" title="自定义ExceptionResolver"></a>自定义ExceptionResolver</h2><p>Spring MVC的异常处理非常的灵活，如果提供的ExceptionResolver类不能满足使用，我们可以实现自己的异常处理类。可以通过继承SimpleMappingExceptionResolver来定制Mapping的方式和能力，也可以直接继承AbstractHandlerExceptionResolver来实现其它类型的异常处理类。</p>
<h1 id="Spring-MVC是如何创建和使用这些Resolver的？"><a href="#Spring-MVC是如何创建和使用这些Resolver的？" class="headerlink" title="Spring MVC是如何创建和使用这些Resolver的？"></a>Spring MVC是如何创建和使用这些Resolver的？</h1><p>首先看Spring MVC是怎么加载异常处理bean的。</p>
<ol>
<li>Spring MVC有两种加载异常处理类的方式，一种是根据类型，这种情况下，会加载ApplicationContext下所有实现了ExceptionResolver接口的bean，并根据其order属性排序，依次调用；一种是根据名字，这种情况下会加载ApplicationContext下，名字为handlerExceptionResolver的bean。</li>
<li>不管使用那种加载方式，如果在ApplicationContext中没有找到异常处理bean，那么Spring MVC会加载默认的异常处理bean。</li>
<li>默认的异常处理bean定义在DispatcherServlet.properties中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br><span class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br></pre></td></tr></table></figure>
<p>以下代码摘自DispatcherServlet，描述了异常处理类的加载过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the HandlerMappings used by this class.</span><br><span class="line"> * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace,</span><br><span class="line"> * we default to BeanNameUrlHandlerMapping.</span><br><span class="line"> */</span><br><span class="line">private void initHandlerMappings(ApplicationContext context) &#123;</span><br><span class="line">    this.handlerMappings = null;</span><br><span class="line"></span><br><span class="line">    if (this.detectAllHandlerMappings) &#123;</span><br><span class="line">        // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">                BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);</span><br><span class="line">        if (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line">            // We keep HandlerMappings in sorted order.</span><br><span class="line">            OrderComparator.sort(this.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">            this.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            // Ignore, we&apos;ll add a default HandlerMapping later.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ensure we have at least one HandlerMapping, by registering</span><br><span class="line">    // a default HandlerMapping if no other mappings are found.</span><br><span class="line">    if (this.handlerMappings == null) &#123;</span><br><span class="line">        this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No HandlerMappings found in servlet &apos;&quot; + getServletName() + &quot;&apos;: using default&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后看Spring MVC是怎么使用异常处理bean的。</p>
<ol>
<li>Spring MVC把请求映射和处理过程放到try catch中，捕获到异常后，使用异常处理bean进行处理。</li>
<li>所有异常处理bean按照order属性排序，在处理过程中，遇到第一个成功处理异常的异常处理bean之后，不再调用后续的异常处理bean。<br>以下代码摘自DispatcherServlet，描述了处理异常的过程。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Process the actual dispatching to the handler.</span><br><span class="line"> * &lt;p&gt;The handler will be obtained by applying the servlet&apos;s HandlerMappings in order.</span><br><span class="line"> * The HandlerAdapter will be obtained by querying the servlet&apos;s installed HandlerAdapters</span><br><span class="line"> * to find the first that supports the handler class.</span><br><span class="line"> * &lt;p&gt;All HTTP methods are handled by this method. It&apos;s up to HandlerAdapters or handlers</span><br><span class="line"> * themselves to decide which methods are acceptable.</span><br><span class="line"> * @param request current HTTP request</span><br><span class="line"> * @param response current HTTP response</span><br><span class="line"> * @throws Exception in case of any kind of processing failure</span><br><span class="line"> */</span><br><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = null;</span><br><span class="line">    boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ModelAndView mv = null;</span><br><span class="line">        Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            // Determine handler for the current request.</span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Determine handler adapter for the current request.</span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            // Process last-modified header, if supported by the handler.</span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">            if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Actually invoke the handler.</span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error err) &#123;</span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            // Instead of postHandle and afterCompletion</span><br><span class="line">            if (mappedHandler != null) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // Clean up any resources used by a multipart request.</span><br><span class="line">            if (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Determine an error ModelAndView via the registered HandlerExceptionResolvers.</span><br><span class="line"> * @param request current HTTP request</span><br><span class="line"> * @param response current HTTP response</span><br><span class="line"> * @param handler the executed handler, or &#123;@code null&#125; if none chosen at the time of the exception</span><br><span class="line"> * (for example, if multipart resolution failed)</span><br><span class="line"> * @param ex the exception that got thrown during handler execution</span><br><span class="line"> * @return a corresponding ModelAndView to forward to</span><br><span class="line"> * @throws Exception if no error ModelAndView found</span><br><span class="line"> */</span><br><span class="line">protected ModelAndView processHandlerException(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">        Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // Check registered HandlerExceptionResolvers...</span><br><span class="line">    ModelAndView exMv = null;</span><br><span class="line">    for (HandlerExceptionResolver handlerExceptionResolver : this.handlerExceptionResolvers) &#123;</span><br><span class="line">        exMv = handlerExceptionResolver.resolveException(request, response, handler, ex);</span><br><span class="line">        if (exMv != null) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exMv != null) &#123;</span><br><span class="line">        if (exMv.isEmpty()) &#123;</span><br><span class="line">            request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // We might still need view name translation for a plain error model...</span><br><span class="line">        if (!exMv.hasView()) &#123;</span><br><span class="line">            exMv.setViewName(getDefaultViewName(request));</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Handler execution resulted in exception - forwarding to resolved error view: &quot; + exMv, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());</span><br><span class="line">        return exMv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="何时该使用何种ExceptionResolver？"><a href="#何时该使用何种ExceptionResolver？" class="headerlink" title="何时该使用何种ExceptionResolver？"></a>何时该使用何种ExceptionResolver？</h1><p>Spring提供了很多选择和非常灵活的使用方式，下面是一些使用建议：</p>
<ol>
<li>如果自定义异常类，考虑加上ResponseStatus注解；</li>
<li>对于没有ResponseStatus注解的异常，可以通过使用ExceptionHandler+ControllerAdvice注解，或者通过配置SimpleMappingExceptionResolver，来为整个Web应用提供统一的异常处理。</li>
<li>如果应用中有些异常处理方式，只针对特定的Controller使用，那么在这个Controller中使用ExceptionHandler注解。</li>
<li>不要使用过多的异常处理方式，不然的话，维护起来会很苦恼，因为异常的处理分散在很多不同的地方。</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/09/13/Spring Boot异常处理详解/">Spring Boot异常处理详解</a><a class="next" href="/2018/09/11/spring Cloud组件超时整理/">Spring Cloud组件超时整理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yuchanghui.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Boot/">Spring Boot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-datterns/">design datterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shiro/">shiro</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/zuul/" style="font-size: 15px;">zuul</a> <a href="/tags/JWT/" style="font-size: 15px;">JWT</a> <a href="/tags/memcache/" style="font-size: 15px;">memcache</a> <a href="/tags/tair/" style="font-size: 15px;">tair</a> <a href="/tags/concurrent/" style="font-size: 15px;">concurrent</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/javassist/" style="font-size: 15px;">javassist</a> <a href="/tags/feign/" style="font-size: 15px;">feign</a> <a href="/tags/ribbon/" style="font-size: 15px;">ribbon</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/druid/" style="font-size: 15px;">druid</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/25/druid获取连接假死/">Druid获取连接假死</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/24/druid连接池介绍/">Druid连接池介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/12/2018全新互联网Java架构技术体系路线/">2018全新互联网Java架构技术体系路线</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/Spring常用核心源码/">Spring常用核心源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/11/Spring Cloud Zuul源码解析/">Spring Cloud Zuul源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/30/mysql分区/">mysql分区</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/Spring Boot异常处理详解/">Spring Boot异常处理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/13/Spring MVC异常处理详解/">Spring MVC异常处理详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/spring Cloud组件超时整理/">Spring Cloud组件超时整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/11/Spring Cloud Zuul服务转发源码详解/">Spring Cloud Zuul服务转发源码详解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="http://www.infoq.com/cn/" title="InfoQ" target="_blank">InfoQ</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Charrington House.</a> Powered by Buyi.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>