<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Zuul源码详细说明 | Charrington House</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Zuul源码详细说明</h1><a id="logo" href="/.">Charrington House</a><p class="description">是谁出的题这么难啊，到处都是正确的答案。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Zuul源码详细说明</h1><div class="post-meta">Aug 28, 2018<span> | </span><span class="category"><a href="/categories/Spring-Cloud/">Spring Cloud</a></span></div><div class="post-content"><h1 id="Zuul简介"><a href="#Zuul简介" class="headerlink" title="Zuul简介"></a>Zuul简介</h1><p>zuul主要做反向代理、负载均衡、fallback回退。它包含了对请求的路由和过滤两个功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的地址；而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。</p>
<p>然而实际上，路由功能在真正运行时，它的路由映射和请求转发都是由几个不同的过滤器完成的。其中，路由映射主要通过pre类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址；而请求转发的部分则是由route类型的过滤器来完成，对pre类型过滤器获得的路由地址进行转发。</p>
<p>所以，过滤器可以说是Zuul实现API网关功能最为核心的部件，每一个进入Zuul的HTTP请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。</p>
<h1 id="搭建zuul"><a href="#搭建zuul" class="headerlink" title="搭建zuul"></a>搭建zuul</h1><ol>
<li><p>pom.xml添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置application.properites文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=buyi-zuul</span><br><span class="line">server.port=8899</span><br><span class="line">#这里的配置表示，访问/it/** 直接重定向到http://www.baidu.com/**</span><br><span class="line">zuul.routes.baidu.path=/it/**</span><br><span class="line">zuul.routes.baidu.url=http://www.baidu.com/</span><br><span class="line">#服务映射的路径，通过这路径就可以从外部访问你的服务了，目的是为了不爆露你机器的IP，面向服务的路由了，给你选一个可用的出来，</span><br><span class="line">zuul.routes.buyi-client.path=/buyi-client/**</span><br><span class="line">zuul.routes..buyi-client.service-id=buyi-client</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>zuul的配置的全部属性见<code>org.springframework.cloud.netflix.zuul.filters.ZuulProperties</code>，其具体相关属性的作用，会在后面详细介绍。</p>
<ol start="3">
<li>启动类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">//@SpringCloudApplication</span><br><span class="line">public class BuyiZuulApplication &#123;</span><br><span class="line">2</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(BuyiZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上就看看到zuul进行请求分发。</p>
<h1 id="forward跳转"><a href="#forward跳转" class="headerlink" title="forward跳转"></a>forward跳转</h1><p>一般情况下API网关只是作为系统的统一入口，但是有时候我们可能也需要在API网关上做一点业务逻辑操作。我们可以在buyi-zuul项目中新建一个controller。</p>
<ol>
<li>application.properities配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#forward会直接路由到zuul的controller,path要带星号</span><br><span class="line">zuul.routes.local.path=/local/**</span><br><span class="line">zuul.routes..local.url=forward:/local</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>控制器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/localh&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello buyi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际的项目场景中，遇到过页面跳转的情况，在这种场景下，forward使用方式就很合适。</p>
</blockquote>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>过滤器排序号数字越大，优先级越低<br>zuul的Filter的生命周期，如下图：<br><img src="https://i.imgur.com/sZicSuN.png" alt=""></p>
<h2 id="过滤器扩展"><a href="#过滤器扩展" class="headerlink" title="过滤器扩展"></a>过滤器扩展</h2><ol>
<li>继承ZuulFilter类，就可以实现扩展过滤的功能。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.buyi.cloud.zuul.filters;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line">import com.netflix.zuul.exception.ZuulException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">public class TestFilter extends ZuulFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        // 优先级为0，数字越大，优先级越低 </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        // 是否执行该过滤器，此处为true，说明需要过滤</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() throws ZuulException &#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(&quot;%s AccessUserNameFilter request to %s&quot;, request.getMethod(), request.getRequestURL().toString()));</span><br><span class="line"></span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);// 获取请求的参数</span><br><span class="line">        if(null != username &amp;&amp; username.equals(&quot;chhliu&quot;)) &#123;// 如果请求的参数不为空，且值为chhliu时，则通过</span><br><span class="line">            ctx.setSendZuulResponse(true);// 对该请求进行路由</span><br><span class="line">            ctx.setResponseStatusCode(200);</span><br><span class="line">            ctx.set(&quot;isSuccess&quot;, true);// 设值，让下一个Filter看到上一个Filter的状态</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ctx.setSendZuulResponse(false);// 过滤该请求，不对其进行路由</span><br><span class="line">            ctx.setResponseStatusCode(401);// 返回错误码</span><br><span class="line">            ctx.setResponseBody(&quot;&#123;\&quot;result\&quot;:\&quot;username is not correct!\&quot;&#125;&quot;);// 返回错误内容</span><br><span class="line">            ctx.set(&quot;isSuccess&quot;, false);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们各自的含义与功能总结如下：</p>
<ul>
<li>filterType：该函数需要返回一个字符串来代表过滤器的类型，而这个类型就是在HTTP请求过程中定义的各个阶段。在Zuul中默认定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li>pre：可以在请求被路由之前调用。</li>
<li>routing：在路由请求时候被调用。</li>
<li>post：在routing和error过滤器之后被调用。</li>
<li>error：处理请求时发生错误时被调用。</li>
</ul>
</li>
<li>filterOrder：通过int值来定义过滤器的执行顺序，数值越小优先级越高。</li>
<li>shouldFilter：返回一个boolean类型来判断该过滤器是否要执行。我们可以通过此方法来指定过滤器的有效范围。</li>
<li>run：过滤器的具体逻辑。在该函数中，我们可以实现自定义的过滤逻辑，来确定是否要拦截当前的请求，不对其进行后续的路由，或是在请求路由返回结果之后，对处理结果做一些加工等。</li>
</ul>
<p>从上图中，我们可以看到，当外部HTTP请求到达API网关服务的时候，首先它会进入第一个阶段pre，在这里它会被pre类型的过滤器进行处理，该类型的过滤器主要目的是在进行请求路由之前做一些前置加工，比如请求的校验等。</p>
<p>在完成了pre类型的过滤器处理之后，请求进入第二个阶段routing，也就是之前说的路由请求转发阶段，请求将会被routing类型过滤器处理，这里的具体处理内容就是将外部请求转发到具体服务实例上去的过程，当服务实例将请求结果都返回之后，routing阶段完成，请求进入第三个阶段post，此时请求将会被post类型的过滤器进行处理，这些过滤器在处理的时候不仅可以获取到请求信息，还能获取到服务实例的返回信息，所以在post类型的过滤器中，我们可以对处理结果进行一些加工或转换等内容。</p>
<p>另外，还有一个特殊的阶段error，该阶段只有在上述三个阶段中发生异常的时候才会触发，但是它的最后流向还是post类型的过滤器，因为它需要通过post过滤器将最终结果返回给请求客户端（实际实现上还有一些差别)</p>
<h2 id="过滤器源码"><a href="#过滤器源码" class="headerlink" title="过滤器源码"></a>过滤器源码</h2><p>Zuul自带的核心过滤器：<br><img src="https://i.imgur.com/0AsYJ5N.png" alt=""></p>
<p>如上图所示，在默认启用的过滤器中包含了三种不同生命周期的过滤器，这些过滤器都非常重要，可以帮助我们理解Zuul对外部请求处理的过程，以及帮助我们如何在此基础上扩展过滤器去完成自身系统需要的功能。下面，我们将逐个地对这些过滤器做一些详细的介绍。</p>
<h3 id="pre过滤器"><a href="#pre过滤器" class="headerlink" title="pre过滤器"></a>pre过滤器</h3><p>ServletDetectionFilter：它的执行顺序为-3，是最先被执行的过滤器。该过滤器总是会被执行，主要用来检测当前请求是通过Spring的DispatcherServlet处理运行，还是通过ZuulServlet来处理运行的。</p>
<p>它的检测结果会以布尔类型保存在当前请求上下文的isDispatcherServletRequest参数中，这样在后续的过滤器中，我们就可以通过RequestUtils.isDispatcherServletRequest()和RequestUtils.isZuulServletRequest()方法判断它以实现做不同的处理。</p>
<p>一般情况下，发送到API网关的外部请求都会被Spring的DispatcherServlet处理，除了通过/zuul/路径访问的请求会绕过DispatcherServlet，被ZuulServlet处理，主要用来应对处理大文件上传的情况。另外，对于ZuulServlet的访问路径/zuul/，我们可以通过zuul.servletPath参数来进行修改。</p>
<p>Servlet30WrapperFilter：它的执行顺序为-2，是第二个执行的过滤器。目前的实现会对所有请求生效，主要为了将原始的HttpServletRequest包装成Servlet30RequestWrapper对象。<br>FormBodyWrapperFilter：它的执行顺序为-1，是第三个执行的过滤器。</p>
<p>该过滤器仅对两种类请求生效，第一类是Content-Type为application/x-www-form-urlencoded的请求，第二类是Content-Type为multipart/form-data并且是由Spring的DispatcherServlet处理的请求（用到了ServletDetectionFilter的处理结果）。</p>
<p>而该过滤器的主要目的是将符合要求的请求体包装成FormBodyRequestWrapper对象。<br>DebugFilter：它的执行顺序为1，是第四个执行的过滤器。</p>
<p>该过滤器会根据配置参数zuul.debug.request和请求中的debug参数来决定是否执行过滤器中的操作。而它的具体操作内容则是将当前的请求上下文中的debugRouting和debugRequest参数设置为true。</p>
<p>由于在同一个请求的不同生命周期中，都可以访问到这两个值，所以我们在后续的各个过滤器中可以利用这两值来定义一些debug信息，这样当线上环境出现问题的时候，可以通过请求参数的方式来激活这些debug信息以帮助分析问题。</p>
<p>另外，对于请求参数中的debug参数，我们也可以通过zuul.debug.parameter来进行自定义。<br>PreDecorationFilter：它的执行顺序为5，是pre阶段最后被执行的过滤器。该过滤器会判断当前请求上下文中是否存在forward.to和serviceId参数，如果都不存在，那么它就会执行具体过滤器的操作（如果有一个存在的话，说明当前请求已经被处理过了，因为这两个信息就是根据当前请求的路由信息加载进来的）。</p>
<p>而它的具体操作内容就是为当前请求做一些预处理，比如：进行路由规则的匹配、在请求上下文中设置该请求的基本信息以及将路由匹配结果等一些设置信息等，这些信息将是后续过滤器进行处理的重要依据，我们可以通过RequestContext.getCurrentContext()来访问这些信息。</p>
<p>另外，我们还可以在该实现中找到一些对HTTP头请求进行处理的逻辑，其中包含了一些耳熟能详的头域，比如：X-Forwarded-Host、X-Forwarded-Port。</p>
<p>另外，对于这些头域的记录是通过zuul.addProxyHeaders参数进行控制的，而这个参数默认值为true，所以Zuul在请求跳转时默认地会为请求增加X-Forwarded-*头域，包括：X-Forwarded-Host、X-Forwarded-Port、X-Forwarded-For、X-Forwarded-Prefix、X-Forwarded-Proto。</p>
<p>我们也可以通过设置zuul.addProxyHeaders=false关闭对这些头域的添加动作。</p>
<blockquote>
<p>如果在第一个pre过滤器验证就失败了，则后面的过滤器不需要执行了。</p>
</blockquote>
<h3 id="route过滤器"><a href="#route过滤器" class="headerlink" title="route过滤器"></a>route过滤器</h3><p>RibbonRoutingFilter：它的执行顺序为10，是route阶段第一个执行的过滤器。该过滤器只对请求上下文中存在serviceId参数的请求进行处理，即只对通过serviceId配置路由规则的请求生效。而该过滤器的执行逻辑就是面向服务路由的核心，它通过使用Ribbon和Hystrix来向服务实例发起请求，并将服务实例的请求结果返回。<br>SimpleHostRoutingFilter：它的执行顺序为100，是route阶段第二个执行的过滤器。该过滤器只对请求上下文中存在routeHost参数的请求进行处理，即只对通过url配置路由规则的请求生效。而该过滤器的执行逻辑就是直接向routeHost参数的物理地址发起请求，从源码中我们可以知道该请求是直接通过httpclient包实现的，而没有使用Hystrix命令进行包装，所以这类请求并没有线程隔离和断路器的保护。<br>SendForwardFilter：它的执行顺序为500，是route阶段第三个执行的过滤器。该过滤器只对请求上下文中存在forward.to参数的请求进行处理，即用来处理路由规则中的forward本地跳转配置。</p>
<h3 id="post过滤器"><a href="#post过滤器" class="headerlink" title="post过滤器"></a>post过滤器</h3><p>SendErrorFilter：它的执行顺序为0，是post阶段第一个执行的过滤器。该过滤器仅在请求上下文中包含error.status_code参数（由之前执行的过滤器设置的错误编码）并且还没有被该过滤器处理过的时候执行。而该过滤器的具体逻辑就是利用请求上下文中的错误信息来组织成一个forward到API网关/error错误端点的请求来产生错误响应。<br>SendResponseFilter：它的执行顺序为1000，是post阶段最后执行的过滤器。该过滤器会检查请求上下文中是否包含请求响应相关的头信息、响应数据流或是响应体，只有在包含它们其中一个的时候就会执行处理逻辑。而该过滤器的处理逻辑就是利用请求上下文的响应信息来组织需要发送回客户端的响应内容。</p>
<p><img src="https://i.imgur.com/M2RnBBI.png" alt=""></p>
<h1 id="路由定位器"><a href="#路由定位器" class="headerlink" title="路由定位器"></a>路由定位器</h1></div><div class="tags"><a href="/tags/zuul/">zuul</a></div><div class="post-nav"><a class="next" href="/2018/08/20/java8函数式编程/">Java8函数式编程</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://yuchanghui.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-datterns/">design datterns</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shiro/">shiro</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tair/" style="font-size: 15px;">tair</a> <a href="/tags/JWT/" style="font-size: 15px;">JWT</a> <a href="/tags/concurrent/" style="font-size: 15px;">concurrent</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/memcache/" style="font-size: 15px;">memcache</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/feign/" style="font-size: 15px;">feign</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/zuul/" style="font-size: 15px;">zuul</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/ribbon/" style="font-size: 15px;">ribbon</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/zuul源码详细说明/">Zuul源码详细说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/java8函数式编程/">Java8函数式编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/ribbon超时重试源码原理/">FeignClient和Ribbon重试机制区别和联系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/Feign超时重试源码原理/">Feign超时源码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/RxJava 从入门到放弃再到不离不弃/">RxJava 从入门到放弃再到不离不弃</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/设计模式-命令模式/">设计模式-命令模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/02/Feign使用说明/">Feign 使用说明</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/JWT TOKEN实现原理/">JWT TOKEN 实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/Java并发之AQS详解/">Java并发之AQS详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/11/shiro框架简介/">shiro框架简介</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a><ul></ul><a href="http://www.infoq.com/cn/" title="InfoQ" target="_blank">InfoQ</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Charrington House.</a> Powered by Buyi.</div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>